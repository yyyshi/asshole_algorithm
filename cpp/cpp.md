### 1. 存储区域不同导致的语法层面上数据是否可读写的性质不同

* `char* pCh = "hello world";`    //  pCh存储在字符串常量区，所以不能进行写操作（因为这个常量很可能很多地方都在引用，如果在某处修改，那其余的访问这个常量的地方也发生了修改）
* `char ch[] = "hello world";`    //  ch存储在栈区，可以写

### 2. 二进制安全
* c语言中的字符串，通过strlen来计算长度，遇到'\0'后对丢弃后面的字符，这导致c字符串只能用来保存文本数据，不能用来保存图片，音视频，压缩文件等二进制数据，不是二进制安全的
* redis中设计的SDS字符串，在读取数据的时候，通过本身结构中自带的len读取，不会因为'\0'而出现数据被截断的情况，是二进制安全的

### 3. 渐进式rehash
* 如果一次性的将已有的键值对做rehash操作，可能使得服务在某段时间内不可用。采取渐进的方式，在对谋个index进行操作的时候，对他所在的桶做rehash，从而将整个rehash操作分批次进行，可以在保证服务正常的情况下，不会造成长时间的服务不可用，是一种折衷办法

### 4. static关键字
* 修饰变量：
  * 全局变量：static修饰的全局变量和普通的全局变量的存储区是挨着的，都是存放在静态区，不同之处在于staitc修饰的全局变量的作用域是当前文件，比如在文件a.h中声明的staic全局变量是不可以由extern方式被其他文件访问的。而普通的全局变量是可以通过extern的方式来访问的。
  例如：
  a.h文件  中：
  static const int static_count = 100;      // static 修饰的全局变量声明
  const int none_static_const = 10;         // 普通全局变量声明
  
  在另外一个文件中，在不include  a.h头文件的时候，试图通过extern的方式访问a.h中声明的两个全局变量:
  extern static const int static_count;   // 报错：more than one storage class specified
  extern const int none_static_count;     // 不会报错
  原因是: static 修饰的全局变量的访问范围是文件级别，而全局变量的访问级别是整个应用程序。
  但是如果直接通过include的方式包含a.h，那么static修饰的全局变量也是可以被访问的，这里的访问是指不是通过extern的方式的访问。
* 局部变量：通常我们在函数中声明一个变量，在函数结束的时候，这个变量离开作用域，生命周期结束，对应的资源被释放。当时有时候我们希望在两次调用同一个函数时，第一次调用的结果能被第二次使用。此时使用局部静态变量，在变量被声明的时候完成初始化操作，数据被存储在全局数据区，当第二次调用函数时将不再进行初始化操作，即初始化之后，他的生命周期贯穿整个应用程序的声明周期，但是因为是局部变量，所以他的作用域是收到局部变量属性的限制的，只能在函数内部被读写。
* 修饰类的成员：表示这个成员不是属于某个具体对象，而是属于整个class的。staic的成员只能被static修饰成员函数访问，该类的所有对象共享此成员。
* 修饰函数：
* 普通函数：static修饰的普通函数，与全局函数不同的是作用域，static修饰的普通函数只能被当前文件作用域内的其他模块调用
* 类的成员函数：static修饰的类的成员只能访问staic类型的成员。static修饰的成员函数不拥有this指针，所以只能访问static类型的成员和成员函数

### 5. malloc向系统申请内存后，还没有立即为应用程序分配物理内存
* 而是先建立虚拟地址，当第一次访问建立的虚拟地址时，会发生页面中断，之后会为虚拟地址分配对应的物理地址，并建立映射关系

### 6.malloc实现原理

### 7.进程是如何被操作系统执行的

### 8.内存分配算法，调度算法
