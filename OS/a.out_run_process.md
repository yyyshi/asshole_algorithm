### 1. linux下应用程序是如何编译链接到运行的
* 以hello.cpp 文件为例，执行g++ hello.cpp 会默认生成a.out可执行程序。当用户通过./a.out的方式企图执行该应用程序的时候，系统会fock一个新的进程，系统通过系统调用execve根据a.out的文件类型(elf)来找到
对应的处理函数。处理函数先读取ELF文件的头部信息，通过访问段描述表，将PT_LOAD段映射到固定的内存地址上。通过start_thread函数将返回的固定内存地址设置为应用程序入口地址。如果存在动态链接库的段，把控制权交给
动态链接器处理动态链接库对应的信息。
* 编译生成的a.out文件，在linux通过readelf -h a.out， 存在Entry point address:               0x10c0，这个就是当前这个应用程序在编译后就生成的入口地址。
* 用objdump -t a.out 查看符号信息，存在00000000000010c0 g     F .text  000000000000002f              _start，发现便已生成的入口地址对应的符号信息是函数名字_start。

### 2. 文件类型：
* 预处理：
* 编译：语法检查，词法检查，语义检查，代码优化，生成符号表（但是地址可能还没分配或者是不正确的，需要在链接阶段进行符号重定位）
* 汇编：将汇编指令转换成特定平台的机器码，构建.o文件的格式。比如move指令在linux平台上是0102
* 链接：符号重定位，从当前文件开始查找每个符号的地址，如果当前文件没找到，去其他的文件找，都找不到，报错未定义的符号。如果找到多个，报错符号重定义。
数据是一定会产生符号的（这里的数据是指存储在.data中的数据，存储在.bss中的变量不会产生符号），函数只产生一个符号，链接器不关注栈中局部变量，即栈变量不会产生符号。栈变量不属于数据。函数属于指令。

  编译的时候不为符号分配内存地址，在链接的时候才分配内存地址，这里说的内存地址是虚拟地址。
* .o文件：二进制可重定位目标文件

链接:   1. 合并所有obj的段，调整段偏移和长度，合并符号表，进行符号解析
        2. 符号的重定位

bss: better save space，在编译的时候bss段中的数据并不会被分配内存，而是只是在段表中记录了需要占用内存的大小，当程序运行的时候，根据这个记录的大小去分配内存，这样的方式可以减少文件的大小，从而节省磁盘的空间。
段表，符号表
### 局部变量产生符号？？？

只有全局变量(静态或者非静态)才存储在.data段，局部的静态变量const存储在.rodata
链接器只对global的符号进行处理，不会去处理local的符号

局部数据是指令不是数据，没有符号，这里说的局部数据是指全局数据以及静态数据之外的数据，即栈上数据。只有数据和函数才有符号。

### 内存对齐，为什么要内存对齐，如何实现内存对齐
