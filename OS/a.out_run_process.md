### 1. linux下应用程序是如何编译链接到运行的
* 以hello.cpp 文件为例，执行g++ hello.cpp 会默认生成a.out可执行程序。当用户通过./a.out的方式企图执行该应用程序的时候，系统会fock一个新的进程，系统通过系统调用execve根据a.out的文件类型(elf)来找到
对应的处理函数。处理函数先读取ELF文件的头部信息，通过访问段描述表，将PT_LOAD段映射到固定的内存地址上。通过start_thread函数将返回的固定内存地址设置为应用程序入口地址。如果存在动态链接库的段，把控制权交给
动态链接器处理动态链接库对应的信息。
* 编译生成的a.out文件，在linux通过readelf -h a.out， 存在Entry point address:               0x10c0，这个就是当前这个应用程序在编译后就生成的入口地址。
* 用objdump -t a.out 查看符号信息，存在00000000000010c0 g     F .text  000000000000002f              _start，发现便已生成的入口地址对应的符号信息是函数名字_start。

### 2. 文件类型：
* 预处理：
* 编译：语法检查，词法检查，语义检查，代码优化，生成符号表（但是地址可能还没分配或者是不正确的，需要在链接阶段进行符号重定位）
* 汇编：将汇编指令转换成特定平台的机器码，构建.o文件的格式。比如move指令在linux平台上是0102
* 链接：符号重定位，从当前文件开始查找每个符号的地址，如果当前文件没找到，去其他的文件找，都找不到，报错未定义的符号。如果找到多个，报错符号重定义。
数据是一定会产生符号的（这里的数据是指存储在.data中的数据，存储在.bss中的变量不会产生符号），函数只产生一个符号，链接器不关注栈中局部变量，即栈变量不会产生符号。栈变量不属于数据。函数属于指令。

  编译的时候不为符号分配内存地址，在链接的时候才分配内存地址，这里说的内存地址是虚拟地址。
* .o文件：二进制可重定位目标文件

链接:   1. 合并所有obj的段，调整段偏移和长度，合并符号表，进行符号解析
        2. 符号的重定位

bss: better save space，在编译的时候bss段中的数据并不会被分配内存，而是只是在段表中记录了需要占用内存的大小，当程序运行的时候，根据这个记录的大小去分配内存，这样的方式可以减少文件的大小，从而节省磁盘的空间。
段表，符号表
### 局部变量产生符号？？？

只有全局变量(静态或者非静态)才存储在.data段，局部的静态变量const存储在.rodata
链接器只对global的符号进行处理，不会去处理local的符号

局部数据是指令不是数据，没有符号，这里说的局部数据是指全局数据以及静态数据之外的数据，即栈上数据。只有数据和函数才有符号。

### 内存对齐，为什么要内存对齐，如何实现内存对齐
1. 便于移植
2. 提高性能

### linux系统内存布局

32位举例
内核1G，用户3G                     高地址
环境变量
命令行
栈区
|
堆区
.bss
.data
.text
保留段   0x8084                    低地址

符号的引用：只能看到声明，不能看到定义的符号，叫做符号的引用

符号的解析：所有obj符号表中对符号引用的地方，都要找到该符号定义的地方

可执行文件是按照页面对齐的，linux常用的页面大小是4k

### 内存映射

### 可执行文件是按照页面对齐的
这也就是为什么一个简单的hello程序，在编译链接生成的可执行程序都是几k。而链接之前的.ow文件很小。

### 链接过程
生成的所有.o文件先进行合并，合并是按属性合并(是否可读可写可执行)来进行.o文件到可执行文件的合并。合并符号表的目的是为了符号解析，即为所有引用的符号找到它定义的地方。
当符号解析完毕之后，即每个符号都能找到它定义的地方，此时会为符号分配内存地址(此时每个符号都获取到了合法的虚拟内存地址空间地址，所以需要调整一下之前非法的符号地址，也就是重定位)，之后进行符号重定位。重定位就是将为符号分配地址之前的非法地址在符号地址分配之后进行一次更新操作。

数据的符号地址存放的都是虚拟内存地址，函数符号存放的都是相对于下一个指令地址的偏移量，即相对地址，用来进行跳转。
