### tcp网络本质上处理的是三个半事件：
* 连接建立：服务器accept（被动）接受连接，客户端connect（主动）连接
* 连接断开：主动断开（close，shutdown），被动断开（read返回0）
* 消息到达：文件描述符可读
* 消息发送完毕：这个算半个。对于低流量服务，可不必关心这个事件，这里的发送完毕指的是数据写入操作系统内核的缓冲区，将由tcp协议栈负责数据的发送和重传，不代表对方已经接受到数据（是否会发生数据丢失？）。

每个socket套接字都有两个缓冲区，发送缓冲区和接收缓冲区。
* 当一个套接字由数据包到来的时候，先被内核接收到内核的缓冲区中，之后网络库的可读事件触发，将数据从内核缓冲区拷贝到应用程序的缓冲区当中，同时调用回调函数OnMessage。如果发现完整的数据包，进行
read，decode，compute，encode，write。loop继续事件循环...
* 当数据全部填充到内核缓冲区，网路库回调函数OmWriteComplete调用。（如果内核缓冲区不足以容纳更多的数据，要把数据追加到用户缓冲区）。

### 简述TCP协议在数据传输过程中收发双方是如何保证数据包的可靠性的
* 为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区； 
* 并为每个已发送的数据包启动一个超时定时器； 
* 如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区; 
* 否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。
* 接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。

### tcp从协议栈的层面是会保证数据安全到达对端内核缓冲区的
* 以流的方式发送数据。即进行序列化和反序列化的操作。todo（流的方式，字符串的方式，以及代码中直接写的结构体的方式？？？）


### 系统缓冲区大小，用户缓冲区大小？？？
* 只有tcp才有接收/发送缓冲区，udp没有

### TCP的接收缓冲区满了，收到数据后会向发送方发送ACK吗？
* TCP的发送缓冲区中的数据，如果收不到接收方的ACK就不会删除，导致发送缓冲区溢出。如果接收方的缓冲区满了，收到数据后会不会向发送方发ACK呢？如果不发ACK，那么就没有接收缓冲区溢出的概念了，只要控制住发 送方，就不会丢包；如果发ACK，那发送方就没办法控制是否继续发送了，接收缓冲区就会造成溢出，导致丢包。事实是怎样的呢？我这样理解正确吗？
* 答案：1. 只要收到了包，就会ACK。
2. TCP在ACK的同时会带有window大小值，表示这边能接受的数据量。发送方会根据这个调整数据量。
3. 接收方缓冲区满时，回给发送方的window值就是0。
4. 发送方看到window为0的包，会启动一个定时器，隔一段时间发一个包试探。
5. 一旦接收方缓冲区有足够空间了，就会给window赋上非0值。发送方就又开始发送了。

### 对tcp沾包问题的理解
* 其实tcp是流式通讯协议，并没有包的概念。关键在于如何将流动的数据一段一段的取出来。
